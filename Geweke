# Geweke

# In the function, I calculate "Geweke's statistic", which is used to test the convergence of the Markov chain. The calculation method of 
# this statistic is to take the first a*n samples and the last b*n samples of the chain as two independent sample sets, calculate the 
# standardized value of the mean difference of the two sample sets, and then use the two-sided t distribution Tests whether this 
# normalized value is significantly different from zero.
# In the code, I provided two ways to calculate the sample variance, one is the var() function, and the other is the power spectral 
# density estimate calculated by the spectrum0.ar() function. Users should choose which method to use for calculation through the method 
# parameter.


# This is an example function that only outputs the statistics in the geweke test once, that is to say, regardless of batch.
# By default we calculate the difference between first a = 10% part and last b = 50% part.

geweke_toy <- function(chain, a = 0.1, b = 0.5, method = "coda") {
  n <- length(chain)
  A <- floor(a * n)
  B <- floor(b * n) 
  # Calculating Geweke’s statistic
  if (method == "normal"){
    ssa <- var(chain[1:A])
    ssb <- var(chain[B:n-1])
    z <- (mean(chain[1:A]) - mean(chain[B:n-1])) / 
      sqrt(ssa / length(chain[1:A]) + ssb / length(chain[B:n-1]))
  }
  
  else if (method == "coda"){
    # This ssa and ssb are the another calculating method of variance (The spectral density at frequency zero) which are using in "coda"
    # Specifically, the spectrum0.ar function performs an autoregressive fit on time series data and computes the variance of the 
    # fitted residuals. This variance can be used as the variance estimate required in the calculation of the Geweke statistic.

    ssa <- spectrum0.ar(chain[1:A])$spec
    ssb <- spectrum0.ar(chain[B:n-1])$spec
    z <- (mean(chain[1:A]) - mean(chain[B:n-1])) / 
      sqrt(ssa / length(chain[1:A]) + ssb / length(chain[B:n-1]))
  }
  
  p_value <- 2 * pmin(pnorm(abs(z), lower.tail = FALSE), pnorm(abs(z), lower.tail = TRUE))
  result <- list(z, p_value)
  names(result) <- c("Geweke’s statistic", "p_value")
  return(result)
}


spectrum0.ar <- function (x) 
{
  x <- as.matrix(x)
  v0 <- order <- numeric(ncol(x))
  names(v0) <- names(order) <- colnames(x)
  z <- 1:nrow(x)
  for (i in 1:ncol(x)) {
    lm.out <- lm(x[, i] ~ z)
    if (identical(all.equal(sd(residuals(lm.out)), 0), TRUE)) {
      v0[i] <- 0
      order[i] <- 0
    }
    else {
      ar.out <- ar(x[, i], aic = TRUE)
      v0[i] <- ar.out$var.pred/(1 - sum(ar.out$ar))^2
      order[i] <- ar.out$order
    }
  }
  return(list(spec = v0, order = order))
}

geweke_toy(chain,method = "coda")   
# $`Geweke’s statistic`
# [1] 0.9614776
# $p_value
# [1] 0.3363121

geweke_toy(chain2,method = "coda")
# $`Geweke’s statistic`
# [1] 0.7455853
# $p_value
# [1] 0.455918

